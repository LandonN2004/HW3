Name:Landon Norris
Course: MAE 3403 - Computer Methods
File HW3C
# Use Cholesky if A is symmetric positive definite; otherwise use Doolittle (LU)

from math import sqrt

# ----------------------------
# Helpers
# ----------------------------
def is_symmetric(A, tol=1e-12):
    n = len(A)
    for i in range(n):
        for j in range(i + 1, n):
            if abs(A[i][j] - A[j][i]) > tol:
                return False
    return True


def cholesky_factor(A, tol=1e-14):
    """
    Return lower-triangular L such that A = L L^T.
    Raises ValueError if A is not positive definite (or numerically unstable).
    """
    n = len(A)
    L = [[0.0 for _ in range(n)] for _ in range(n)]

    for j in range(n):
        # diagonal element
        s = 0.0
        for k in range(j):
            s += L[j][k] ** 2
        val = A[j][j] - s
        if val <= tol:
            raise ValueError("Not positive definite (Cholesky failed).")
        Ljj = sqrt(val)
        L[j][j] = Ljj

        # below-diagonal elements
        for i in range(j + 1, n):
            s = 0.0
            for k in range(j):
                s += L[i][k] * L[j][k]
            L[i][j] = (A[i][j] - s) / Ljj

    return L


def forward_sub(L, b):
    """Solve L y = b for y where L is lower-triangular."""
    n = len(L)
    y = [0.0] * n
    for i in range(n):
        s = 0.0
        for j in range(i):
            s += L[i][j] * y[j]
        y[i] = (b[i] - s) / L[i][i]
    return y


def back_sub(U, y):
    """Solve U x = y for x where U is upper-triangular."""
    n = len(U)
    x = [0.0] * n
    for i in range(n - 1, -1, -1):
        s = 0.0
        for j in range(i + 1, n):
            s += U[i][j] * x[j]
        x[i] = (y[i] - s) / U[i][i]
    return x


def transpose(M):
    n = len(M)
    return [[M[j][i] for j in range(n)] for i in range(n)]


def lu_doolittle(A):
    """
    Doolittle LU factorization WITHOUT pivoting:
      A = L U, where L has 1's on diagonal.
    Raises ValueError if zero pivot encountered.
    """
    n = len(A)
    L = [[0.0] * n for _ in range(n)]
    U = [[0.0] * n for _ in range(n)]

    for i in range(n):
        L[i][i] = 1.0

    for i in range(n):
        # compute U row i
        for j in range(i, n):
            s = 0.0
            for k in range(i):
                s += L[i][k] * U[k][j]
            U[i][j] = A[i][j] - s

        if abs(U[i][i]) < 1e-14:
            raise ValueError("Zero (or tiny) pivot in LU. (Need pivoting.)")

        # compute L column i
        for j in range(i + 1, n):
            s = 0.0
            for k in range(i):
                s += L[j][k] * U[k][i]
            L[j][i] = (A[j][i] - s) / U[i][i]

    return L, U


def solve_system(A, b):
    """
    Decide method and solve Ax=b.
    Returns (x, method_string).
    """
    sym = is_symmetric(A)

    if sym:
        try:
            L = cholesky_factor(A)
            y = forward_sub(L, b)
            Lt = transpose(L)
            x = back_sub(Lt, y)
            return x, "Cholesky"
        except ValueError:
            pass  # symmetric but not PD -> fall back to LU

    # LU fallback
    L, U = lu_doolittle(A)
    y = forward_sub(L, b)
    x = back_sub(U, y)
    return x, "Doolittle (LU)"


def print_solution(x, method):
    print(f"Method used: {method}")
    for i, xi in enumerate(x, start=1):
        print(f"x{i} = {xi:.6f}")
    print("-" * 40)


# ----------------------------
# Apply to the two HW problems
# ----------------------------
def main():
    # Problem 1 (from HW page 4)
    A1 = [
        [ 1, -1,  3,  2],
        [-1,  5, -5, -2],
        [ 3, -5, 19,  3],
        [ 2, -2,  3, 21]
    ]
    b1 = [15, -35, 94, 1]

    # Problem 2 (from HW page 4)
    A2 = [
        [4, 2, 4, 0],
        [2, 2, 3, 2],
        [4, 3, 6, 3],
        [0, 2, 3, 9]
    ]
    b2 = [20, 36, 60, 122]

    x1, m1 = solve_system(A1, b1)
    print("Problem 1 solution:")
    print_solution(x1, m1)

    x2, m2 = solve_system(A2, b2)
    print("Problem 2 solution:")
    print_solution(x2, m2)


if __name__ == "__main__":
    main()
